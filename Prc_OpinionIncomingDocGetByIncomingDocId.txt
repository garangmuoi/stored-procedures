USE [DHTN-2025]
GO
/****** Object:  StoredProcedure [edoc].[Prc_OpinionIncomingDocGetByIncomingDocId]    Script Date: 9/20/2025 8:52:09 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


-- =============================================
-- Author:		Hung Tran
-- Create date:	18-04-2018
-- Description:	<Description,,>
-- Update detail: https://github.com/selab-dev/qlvb-old-backend/pull/33
-- =============================================
ALTER procedure [edoc].[Prc_OpinionIncomingDocGetByIncomingDocId]
    -- Add the parameters for the stored procedure here
    @IncomingDocId bigint,
    @UserIncomingDocId BIGINT = NULL,
    @OpinionType INT = NULL
	
as
begin
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering SELECT statements.
    set nocount on;

    begin try
        /*******************************************************************************
        * Add SQL statment(s) here.
        * Build up some dynamic SQL to do the search
        *******************************************************************************/

        select oid.Id
              ,oid.IncomingDocId
			  ,oid.UserIncomingDocId
              ,oid.OpinionUserId
			  ,oid.OpinionUserRoleId
              ,oid.Opinion
              ,oid.Status
              ,oid.OpinionDate
              ,oid.OpinionType
              ,UserSendUnitId = r.UnitId
              ,UserSendUnitName = d_send.Name  
			  ,concat(s_send.FirstName, '',s_send.LastName) as OpinionUserName
			  ,r.Name as OpinionUserRoleName
        from edoc.OpinionIncomingDoc (nolock) oid
		LEFT JOIN dbo.Role (NOLOCK) r on r.Id = oid.OpinionUserRoleId
		LEFT JOIN dbo.Department (NOLOCK) d_send ON r.UnitId = d_send.Id
        LEFT JOIN dbo.Staff (nolock) s_send on oid.OpinionUserId = s_send.Id        
        where oid.IncomingDocId = @IncomingDocId
        AND (@OpinionType IS NULL OR oid.OpinionType = @OpinionType)
		AND (@UserIncomingDocId IS NULL OR oid.UserIncomingDocId = @UserIncomingDocId)
        ORDER BY oid.OpinionDate;

    /*******************************************************************************
    * End of SQL statment(s).
    *******************************************************************************/
    end try
    begin catch
        declare @ErrorMessage   nvarchar(max)
               ,@ErrorNumber    int
               ,@ErrorSeverity  int
               ,@ErrorState     int
               ,@ErrorLine      int
               ,@ErrorProcedure nvarchar(200);

        -- Assign variables to error-handling functions that capture information for RAISERROR.
        select @ErrorNumber    = error_number()
              ,@ErrorSeverity  = error_severity()
              ,@ErrorState     = error_state()
              ,@ErrorLine      = error_line()
              ,@ErrorProcedure = isnull(error_procedure(), '-');

        -- Build the message string that will contain original error information.
        select @ErrorMessage = concat(N'Error %d, Level %d, State %d, Procedure %s, Line %d, Message: ', error_message());

        -- Only set the error state if its been set to zero
        if (@ErrorState = 0)
            set @ErrorState = 1;

        -- Raise an error: msg_str parameter of RAISERROR will contain the original error information.
        raiserror(@ErrorMessage
                 ,@ErrorSeverity
                 ,@ErrorState
                 ,@ErrorNumber    -- parameter: original error number.
                 ,@ErrorSeverity  -- parameter: original error severity.
                 ,@ErrorState     -- parameter: original error state.
                 ,@ErrorProcedure -- parameter: original error procedure name.
                 ,@ErrorLine      -- parameter: original error line number.
        );
    end catch;

    set nocount off;
end;

