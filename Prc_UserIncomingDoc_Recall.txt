USE [DHTN-2025]
GO
/****** Object:  StoredProcedure [edoc].[Prc_UserIncomingDoc_Recall]    Script Date: 9/22/2025 10:42:20 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- Author:      Tran Duc Binh
-- Create date: 14/09/2025
-- Description: Thu hồi văn bản
-- =============================================
ALTER PROCEDURE [edoc].[Prc_UserIncomingDoc_Recall]
    @UserIncomingDocs XML = NULL,
    @Opinion NVARCHAR(MAX)
AS
BEGIN
    BEGIN TRY
    BEGIN TRANSACTION;
        --
        -- All other declarations and initialisation
        --
        -- Declare temp table to parse Recipients
		IF OBJECT_ID('tempdb..#UserIncomingDocs') IS NOT NULL
			DROP TABLE UserIncomingDocs;
		CREATE TABLE #UserIncomingDocs
		(
			UserIncomingDocId BIGINT,
			IncomingDocId BIGINT
		);

		-- Parse the XML into the temp table UserIncomingDocs
		INSERT INTO #UserIncomingDocs (UserIncomingDocId, IncomingDocId)
		SELECT 
			x.v.value('(UserIncomingDocId)[1]', 'INT') AS UserIncomingDocId,
			x.v.value('(IncomingDocId)[1]', 'INT') AS IncomingDocId
		FROM @UserIncomingDocs.nodes('/UserIncomingDocs/UserIncomingDoc') x(v);

		-- Cursor to iterate over Recipients
		DECLARE incoming_cursor CURSOR FOR
			SELECT UserIncomingDocId, IncomingDocId
			FROM #UserIncomingDocs
			WHERE UserIncomingDocId IS NOT NULL;

		DECLARE @UserIncomingDocId BIGINT,
				@IncomingDocId BIGINT;

		OPEN incoming_cursor;
		FETCH NEXT FROM incoming_cursor 
		INTO @UserIncomingDocId, @IncomingDocId;

		WHILE @@FETCH_STATUS = 0
		BEGIN
            UPDATE edoc.IncomingDoc SET Status = 13 WHERE Id = @IncomingDocId; -- Status = 13 Lấy Lại Văn Bản

            UPDATE edoc.UserIncomingDoc SET Status = 4 WHERE Id = @UserIncomingDocId; -- Status = 4 Bị Thu Hồi

            UPDATE edoc.OpinionIncomingDoc SET Status = 4, Opinion = @Opinion WHERE 
                IncomingDocId = @IncomingDocId 
                AND UserIncomingDocId = @UserIncomingDocId; -- Status = 4 Bị Thu Hồi

            FETCH NEXT FROM incoming_cursor INTO @UserIncomingDocId, @IncomingDocId;
		END
		
        -- Clean up cursor
        CLOSE incoming_cursor;
		DEALLOCATE incoming_cursor;

    COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;
        DECLARE @ErrorMessage NVARCHAR(MAX),
                @ErrorNumber INT,
                @ErrorSeverity INT,
                @ErrorState INT,
                @ErrorLine INT,
                @ErrorProcedure NVARCHAR(200);

        -- Assign variables to error-handling functions that capture information for RAISERROR.
        SELECT @ErrorNumber = ERROR_NUMBER(),
               @ErrorSeverity = ERROR_SEVERITY(),
               @ErrorState = ERROR_STATE(),
               @ErrorLine = ERROR_LINE(),
               @ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-');

        -- Build the message string that will contain original error information.
        SELECT @ErrorMessage = N'Error %d, Level %d, State %d, Procedure %s, Line %d, Message: ' + ERROR_MESSAGE();

        -- Only set the error state if its been set to zero
        IF (@ErrorState = 0)
            SET @ErrorState = 1;

        -- Raise an error: msg_str parameter of RAISERROR will contain the original error information.
        RAISERROR(   @ErrorMessage,
                     @ErrorSeverity,
                     @ErrorState,
                     @ErrorNumber,    -- parameter: original error number.
                     @ErrorSeverity,  -- parameter: original error severity.
                     @ErrorState,     -- parameter: original error state.
                     @ErrorProcedure, -- parameter: original error procedure name.
                     @ErrorLine       -- parameter: original error line number.
                 );
    END CATCH;
END;
